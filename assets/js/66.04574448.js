(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{151:function(t,e,r){"use strict";r.r(e);var a=r(0),n=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[r("h2",{attrs:{id:"原型链重点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原型链重点","aria-hidden":"true"}},[t._v("#")]),t._v(" 原型链重点")]),t._v(" "),r("h3",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),r("p",[t._v("学习原型之前，先得学习函数，this（函数上下文）,闭包（词法环境、执行上下文）等基础知识，原型是基于对象的，为了让js 也有类的继承风格。在此强推javascript忍者秘籍和javascript 高及程序设计。")]),t._v(" "),r("h3",{attrs:{id:"基本关系图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本关系图","aria-hidden":"true"}},[t._v("#")]),t._v(" 基本关系图")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://github.com/5201314999/jrNote/blob/master/docs/.vuepress/public/more/js/prototype3.png?raw=true",alt:"Image text"}})]),t._v(" "),r("h3",{attrs:{id:"正文"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#正文","aria-hidden":"true"}},[t._v("#")]),t._v(" 正文")]),t._v(" "),r("ol",[r("li",[t._v("关于原型api")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("    person.__proto__===Person.prototype\n    Object.getPrototypeOf(person)===Person.prototype\n    Object.setPrototypeOf(B,a)\n    Person.prototype.constructor === Person \n    person.constructor=== Person\n    \n")])])]),r("p",[r("code",[t._v("注意1")]),t._v("：函数的原型可以被任意替换，已经构建的实例引用旧的原型")]),t._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[t._v("原型链继承")])]),t._v(" "),r("p",[t._v("原型对象也有自己的原型，直到对象的原型为 null 为止（也就是没有原型）。这种一级一级的链结构就称为原型链。原型继承的模型就是JavaScript实现继承的原理。真正形成原型链的是每个对象的__proto__属性，而不是函数的prototype属性，这是很重要的。")]),t._v(" "),r("ul",[r("li",[t._v("说明：")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("    function Person(){}\n    function Adult(){}\n    Adult.prototype=new Person();\n    adult=new Adult();\n    adult instanceOf Person; （判断Person 是不是在adult 原型链上。）\n    Person.prototype.isPrototypeOf(adult)   （判断Person 是不是在adult 原型链上。）\n")])])]),r("p",[r("code",[t._v("注意2:")]),t._v("如Ninja.prototype = Person.prototype。这样做会导致在Person原型上所发生的所有变化都被同步到Ninja原型上（Person原型与Ninja原型是同一个对象），一定会有不良的副作用。new 不会的原因见"),r("code",[t._v("注意1")])]),t._v(" "),r("ul",[r("li",[r("p",[t._v("组合方式（借助调用父类函数和原型链）")]),t._v(" "),r("ul",[r("li",[r("ol",[r("li",[t._v("解决Parent 数组上的有问题，因为"),r("code",[t._v("注意1")]),t._v(",有引用类型的问题")])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"2"}},[r("li",[t._v("可以传参调用父类参数")])])]),t._v(" "),r("li",[t._v("问题：会调用2次父类")])])])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("    function Parent() {\n      this.name = 'parent';\n      this.books=[1,2];\n    }\n    \n    function Child() {\n      Parent.apply(this);  //解决books数组修改会影响所有生成对象的问题，也可解决Object.create 访问不到parent 函数的books 问题，同时可以实现传参给父函数,相当于super()\n    }\n    // 1\n    Child.prototype=new Parent();\n    Child.prototype.constructor=Child;\n\n    // 2\n    Child.prototype=Object.create(Parent);\n    Child.prototype.constructor=Child;\n\n    const a=new Child();  \n    const b=new Child();\n    \n")])])]),r("p",[t._v("疑惑点：new Parent 存在什么问题呢。\n答案：books数组修改会影响所有生成对象")]),t._v(" "),r("h3",{attrs:{id:"理解测试题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#理解测试题","aria-hidden":"true"}},[t._v("#")]),t._v(" 理解测试题")]),t._v(" "),r("ol",[r("li",[t._v("原型链的顶端？ Object.prototype")]),t._v(" "),r("li",[t._v("Array.prototye 和 Array."),r("strong",[t._v("proto")]),t._v(" 有什么区别？")]),t._v(" "),r("li",[t._v("var a={name:11};\nObject.setPrototypeOf(a,null)\nconsole.log(a.toString())")])])])}],!1,null,null,null);n.options.__file="6prototype.md";e.default=n.exports}}]);