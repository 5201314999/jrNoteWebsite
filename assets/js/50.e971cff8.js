(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{183:function(e,t,n){"use strict";n.r(t);var i=n(0),r=Object(i.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[e._m(0),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),n("p",[n("a",{attrs:{href:"https://www.cnblogs.com/yjmyzz/p/webrtc-multiparty-call-architecture.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("架构描述"),n("OutboundLink")],1),e._v(" "),n("a",{attrs:{href:"http://blog.chinaunix.net/uid-26000296-id-4841496.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考教程"),n("OutboundLink")],1)])])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"webrtc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webrtc","aria-hidden":"true"}},[this._v("#")]),this._v(" webrtc")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流程","aria-hidden":"true"}},[this._v("#")]),this._v(" 流程")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ol",[n("li",[e._v("ClientA首先创建PeerConnection对象，然后打开本地音视频设备，将音视频数据封装成MediaStream添加到PeerConnection中。")]),e._v(" "),n("li",[e._v("ClientA调用PeerConnection的CreateOffer方法创建一个用于offer的SDP对象，SDP对象中保存当前音视频的相关参数。ClientA通过PeerConnection的SetLocalDescription方法将该SDP对象保存起来，并通过Signal服务器发送给ClientB。")]),e._v(" "),n("li",[e._v("ClientB接收到ClientA发送过的offer SDP对象，通过PeerConnection的SetRemoteDescription方法将其保存起来，并调用PeerConnection的CreateAnswer方法创建一个应答的SDP对象，通过PeerConnection的SetLocalDescription的方法保存该应答SDP对象并将它通过Signal服务器发送给ClientA。")]),e._v(" "),n("li",[e._v("ClientA接收到ClientB发送过来的应答SDP对象，将其通过PeerConnection的SetRemoteDescription方法保存起来。")]),e._v(" "),n("li",[e._v("在SDP信息的offer/answer流程中，ClientA和ClientB已经根据SDP信息创建好相应的音频Channel和视频Channel并开启Candidate数据的收集，Candidate数据可以简单地理解成Client端的IP地址信息（本地IP地址、公网IP地址、Relay服务端分配的地址）。")]),e._v(" "),n("li",[e._v("当ClientA收集到Candidate信息后，PeerConnection会通过OnIceCandidate接口给ClientA发送通知，ClientA将收到的Candidate信息通过Signal服务器发送给ClientB，ClientB通过PeerConnection的AddIceCandidate方法保存起来。同样的操作ClientB对ClientA再来一次。")]),e._v(" "),n("li",[e._v("这样ClientA和ClientB就已经建立了音视频传输的P2P通道，ClientB接收到ClientA传送过来的音视频流，会通过PeerConnection的OnAddStream回调接口返回一个标识ClientA端音视频流的MediaStream对象，在ClientB端渲染出来即可。同样操作也适应ClientB到ClientA的音视频流的传输。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"几种架构的对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#几种架构的对比","aria-hidden":"true"}},[this._v("#")]),this._v(" 几种架构的对比")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ol",[t("li",[t("p",[this._v("Mesh p2p 不需要服务器，浏览器直连")])]),this._v(" "),t("li",[t("p",[this._v("MCU 中央服务器负责转发，视频编码解码处理，服务器压力大")])]),this._v(" "),t("li",[t("p",[this._v("SFC 依然采用中央服务器作为中转站的架构，减少服务器工作量，只负责转发视频和信令，不做编码解码工作，cpu 较少，每个浏览器都有一个输出通道和n-1 个输入通道，对带宽要求较高，服务器cpu 要求较低。")])])])}],!1,null,null,null);r.options.__file="19webrtc.md";t.default=r.exports}}]);