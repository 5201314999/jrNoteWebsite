(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{159:function(t,a,e){"use strict";e.r(a);var n=e(0),s=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"es6-有趣的知识点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es6-有趣的知识点","aria-hidden":"true"}},[t._v("#")]),t._v(" es6 有趣的知识点")]),t._v(" "),e("h2",{attrs:{id:"_1-尾调用优化-尾递归"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-尾调用优化-尾递归","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.尾调用优化(尾递归)")]),t._v(" "),e("p",[t._v("这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 情况一\nfunction f(x){\n  let y = g(x);\n  return y;\n}\n\n// 情况二\nfunction f(x){\n  return g(x) + 1;\n}\n\n// 情况三\nfunction f(x){\n  g(x);\n}\n\n")])])]),e("p",[t._v("情况三就是尾调用，此处可以做尾调用优化。原因:g(x) 没有用到f(x) 定义的变量")]),t._v(" "),e("p",[t._v("注意：")]),t._v(" "),e("p",[t._v("ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。")]),t._v(" "),e("p",[t._v("这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。")]),t._v(" "),e("p",[t._v("func.arguments：返回调用时函数的参数。\nfunc.caller：返回调用当前函数的那个函数。")]),t._v(" "),e("p",[t._v("不在严格模式下如何实现尾递归的优化，防止堆栈溢出，将递归转换成循环")]),t._v(" "),e("p",[t._v("目前不是完全懂。。以后再看")]),t._v(" "),e("h2",{attrs:{id:"_2-spread-扩展运算符-rest"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-spread-扩展运算符-rest","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.spread 扩展运算符 ...   rest")]),t._v(" "),e("ol",[e("li",[t._v("用于传参")]),t._v(" "),e("li",[t._v("用于伪数组，转数组")])]),t._v(" "),e("h2",{attrs:{id:"_3-箭头函数，解构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-箭头函数，解构赋值","aria-hidden":"true"}},[t._v("#")]),t._v(" 3.箭头函数，解构赋值")])])}],!1,null,null,null);s.options.__file="2es6js.md";a.default=s.exports}}]);