(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{157:function(t,n,e){"use strict";e.r(n);var a=e(0),s=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"防抖和节流的学习"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#防抖和节流的学习","aria-hidden":"true"}},[t._v("#")]),t._v(" 防抖和节流的学习")]),t._v(" "),e("h2",{attrs:{id:"防抖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#防抖","aria-hidden":"true"}},[t._v("#")]),t._v(" 防抖")]),t._v(" "),e("p",[t._v("防抖的原理就是：你尽管触发事件，但是我一定在事件触发结束后 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function debounce(fn,delay){\n    let timeout;\n    let context=this;\n    return (...args)=>{\n        clearTimeout(timeout);\n        setTimeout(()=>{\n            fn.apply(context,args);\n        },delay)\n    }\n}\n\n")])])]),e("h2",{attrs:{id:"节流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#节流","aria-hidden":"true"}},[t._v("#")]),t._v(" 节流")]),t._v(" "),e("p",[t._v("节流的原理很简单：")]),t._v(" "),e("p",[t._v("如果你持续触发事件，每隔一段时间，只执行一次事件。")]),t._v(" "),e("p",[t._v("根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。\n我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。")]),t._v(" "),e("p",[t._v("关于节流的实现")]),t._v(" "),e("p",[t._v("实践过程中为了传参进去写了4个小时，fuck...\n使用闭包的原因是为了共用一个timeout ，throttle 的作用是返回一个新的回调函数。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function throttle(fn, delay) {\n           let lastDate = 0, timeout;\n           let context = this;\n           // console.log(context);\n           return (...args)=> {\n               console.log(args);\n               let nowDate = + new Date();\n               if (nowDate - lastDate >= delay) {\n                   lastDate = nowDate;\n                   fn.apply(context,args);\n               }\n               clearTimeout(timeout);\n               timeout = setTimeout(() => {\n                   fn.apply(context,args);\n               }, delay);\n           }\n       }\n       let obj = {\n           funA: function () {\n               let funB=throttle((event,a)=>{\n                   console.log(a);\n                   console.log('借宿');\n               },2000);\n               document.getElementById('test').addEventListener('mousemove',function(){\n                   funB(event,'222');\n               });\n               \n           }\n       }\n       obj.funA();\n")])])])])}],!1,null,null,null);s.options.__file="3debounce_throttle.md";n.default=s.exports}}]);